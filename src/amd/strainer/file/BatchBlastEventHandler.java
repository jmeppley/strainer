/****** BEGIN LICENSE BLOCK *****
 * This file is part of the Strainer application. To obtain or learn more 
 * about strainer visit: 
 *  http://bioinformatics.org/strainer
 * 
 * Copyright (c) 2007 The Regents of the University of California.  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of the GNU Lesser General Public License as published 
 * by the Free Software Foundation; either version 2.1 of the License, or 
 * (at your option) any later version. You may not use this file except in 
 * compliance with the License. 
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  
 * USA or visit http://www.gnu.org/licenses/lgpl.html
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 * 
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
 * DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS
 * IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
 *
 * Contributor(s):
 *  John Eppley <jmeppley@berkeley.edu>
 * 
 ***** END LICENSE BLOCK ***** */
package amd.strainer.file;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

import amd.strainer.NoGoodClonePlacementException;
import amd.strainer.display.actions.Task;
import amd.strainer.objects.Alignment;
import amd.strainer.objects.Read;
import amd.strainer.objects.ReferenceSequence;
import amd.strainer.objects.Strain;

/**
 * Handles SAX events as generated by BlastLikSAXParser. Used to parse blastn
 * alignments of reads against multiple reference sequences.
 * <p>
 * To generate a files for importing into strainer, first obtain fasta list of
 * reference sequences plus individual sequence files for each reference
 * sequence plus a file of read sequences in FASTA format. First, create a blast
 * DB using just the reference sequences. Next, Blast the list of read sequences
 * against the generated database. Output the results in m0 format. Run
 * Batch.java Using the blast ouput to generate a strainer XML file for each
 * reference sequence. XML files will be named [REF_SEQ_NAME].strains.xml in the
 * working directory.
 * 
 * @author jmeppley
 * 
 */
public class BatchBlastEventHandler extends DefaultHandler {
	// TODO:3 merge with BlastEventHandler
	// There is too much identical code not to

	Map<String, ReferenceSequence> refSeqs = new HashMap<String, ReferenceSequence>();
	private int readIndex = 1;
	private int index = 1;
	private int strainIndex = 1;

	// mate pair separation
	private int smallClone = 0;
	private int bigClone = 10000;

	// save reads as we encounter them
	private Read currentRead = null;
	private final Map<String, Read> soloReads = new HashMap<String, Read>();
	private Map<String, Alignment> currentReadAlignments = new HashMap<String, Alignment>();
	private final Map<Read, Map<String, Alignment>> readAlignmentsMap = new HashMap<Read, Map<String, Alignment>>();

	// Alignment data
	private String subjectId = null;
	private boolean dir = true;
	private int score = 0;
	private int length = 0;
	private String eValue = null;
	private int astart = 0;
	private int aend = 0;
	private boolean inSequence = false;
	private final StringBuffer chars = new StringBuffer();
	private String query = null;
	private String match = null;
	private String hit = null;
	private String cigar = null;
	private Task task = null;

	/**
	 * Creates the event handler.
	 * 
	 * @param pSmallClone
	 *            the smallest clone size (separation of matepairs) expected
	 * @param pBigClone
	 *            the largest clone size expected
	 */
	public BatchBlastEventHandler(int pSmallClone, int pBigClone, Task pTask) {
		this.smallClone = pSmallClone;
		this.bigClone = pBigClone;
		this.task = pTask;
	}

	/**
	 * Receive notification of the beginning of a document. (ignored)
	 */
	@Override
	public void startDocument() {
	}

	/**
	 * Receive notification of the beginning of an element.
	 */
	@Override
	public void startElement(java.lang.String uri, java.lang.String localName,
			java.lang.String qName, Attributes atts) {
		if (task != null && task.isInterrupted()) {
			throw new RuntimeException("Interrupted!");
		}

		if (qName.equals("biojava:BlastLikeDataSet")) {
			// initialize read
			currentRead = new Read();
			currentRead.setId(readIndex++);
		} else if (currentRead != null) {
			if (qName.equals("biojava:QueryId")) {
				// get the read name
				currentRead.setName(atts.getValue("id"));
			} else if (qName.equals("biojava:HitId")) {
				// store name of sequence matched
				subjectId = atts.getValue("id");
			} else if (qName.equals("biojava:HSPSummary")) {
				// save alignment info
				dir = atts.getValue("hitStrand").equals(
						atts.getValue("queryStrand"));
				score = (int) Float.parseFloat(atts.getValue("score"));
				length = Integer.parseInt(atts.getValue("alignmentSize"));
				eValue = atts.getValue("expectValue");
			} else if (qName.equals("biojava:QuerySequence")) {
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			} else if (qName.equals("biojava:MatchConsensus")) {
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			} else if (qName.equals("biojava:CigarString")) {
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			} else if (qName.equals("biojava:HitSequence")) {
				// get alignment position
				astart = Integer.parseInt(atts.getValue("startPosition"));
				aend = Integer.parseInt(atts.getValue("stopPosition"));
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			}
		}
	}

	/**
	 * Receive notification of character data.
	 */
	@Override
	public void characters(char[] ch, int start, int length) {
		if (inSequence) {
			// save data if we are in a sequence element only
			chars.append(ch, start, length);
		}
	}

	/**
	 * Receive notification of the end of an element.
	 */
	@Override
	public void endElement(java.lang.String uri, java.lang.String localName,
			java.lang.String qName) {
		if (task != null && task.isInterrupted()) {
			throw new RuntimeException("Interrupted!");
		}

		if (qName.equals("biojava:BlastLikeDataSetCollection")) {
			System.out.println("end of file");

			// look through leftover reads and add to entry with best alignments
			processSoloReads(readAlignmentsMap);

		} else if (currentRead != null) {
			if (qName.equals("biojava:BlastLikeDataSet")) {
				// end of read. Clean up and save

				if (currentRead.getName() == null
						|| currentReadAlignments.size() == 0) {
					// ncomplete record, skip
					return;
				}

				// check if we've seen it's matepair...
				Read matePair = Util.lookForMatePair(soloReads, currentRead,
						false);

				// if so ...
				if (matePair != null) {
					// if we've seen the mate pair...
					// choose which aligment is best for this pair
					Map<String, Alignment> mpAligs = readAlignmentsMap
							.remove(matePair);
					if (!findBestAlignments(currentRead, currentReadAlignments,
							matePair, mpAligs)) {
						// if nothing fell within tolerances, choose the best
						// individual scores
						findBestAlignment(currentRead, currentReadAlignments);
						findBestAlignment(matePair, mpAligs);

						if (currentRead.getAlignment().getSequenceSegment1()
								.getSequence() != matePair.getAlignment()
								.getSequenceSegment1().getSequence()) {
							currentRead.setMatepair(null);
							matePair.setMatepair(null);
						}
					} else {
						// associate mate pairs
						currentRead.setMatepair(matePair);
					}
				} else {
					// if we haven't seen the mate pair yet...
					// save alignments for later and wait for mate pair to come
					// around
					readAlignmentsMap.put(currentRead, currentReadAlignments);
				}

				// reset vars
				currentRead = null;
				currentReadAlignments = new HashMap<String, Alignment>();
			} else if (qName.equals("biojava:HSP")) {
				ReferenceSequence referenceSequence = refSeqs.get(subjectId);
				if (referenceSequence == null) {
					// System.out.println("New ref seq: " + subjectId);
					referenceSequence = new ReferenceSequence();
					referenceSequence.setId(index++);
					referenceSequence.setName(subjectId);
					refSeqs.put(subjectId, referenceSequence);
				}
				Alignment a;
				// end of an HSP, add just created Alignment to list of
				// possibles for this read
				if (match != null) {
					a = Util.buildAlignmentFromBlastData(currentRead,
							referenceSequence, dir, astart, aend, score,
							length, eValue, query, match, hit);
				} else if (cigar != null) {
					a = Util.buildAlignmentFromCigarString(currentRead,
							referenceSequence, dir, astart, score, eValue,
							query, cigar);
				} else {
					throw new RuntimeException(
							"Did not get a match string or cigar string. This file is not readable.");
				}
				currentReadAlignments.put(subjectId, a);
			} else if (qName.equals("biojava:QuerySequence")) {
				query = chars.toString();
				inSequence = false;
			} else if (qName.equals("biojava:MatchConsensus")) {
				match = chars.toString();
				inSequence = false;
			} else if (qName.equals("biojava:HitSequence")) {
				hit = chars.toString();
				inSequence = false;
			} else if (qName.equals("biojava:CigarString")) {
				cigar = chars.toString();
				inSequence = false;
			}
		}
	}

	/**
	 * Receive notification of the end of a document.
	 */
	@Override
	public void endDocument() {
	}

	/**
	 * loops over reference sequences and saves them to XML files in the
	 * specified directory.
	 * 
	 * @param pOutputDir
	 *            the directory to save XML files. Write to working directory if
	 *            null
	 * @throws IOException
	 *             if pOutputDir is not a directory or cannot be created
	 * @throws InterruptedException
	 */
	void writeReferenceSequencesToXML(File pOutputDir) throws IOException,
			InterruptedException {
		// don't prepend names if outputdir is null
		String fileNamePrefix = "";

		// check output dir
		if (pOutputDir != null) {
			if (pOutputDir.exists()) {
				if (!pOutputDir.isDirectory()) {
					throw new IOException("Not a directory: "
							+ pOutputDir.getAbsolutePath());
				}
			} else {
				if (!pOutputDir.mkdirs()) {
					throw new IOException("Could not create directory: "
							+ pOutputDir.getAbsolutePath());
				}
			}

			// set up file names
			fileNamePrefix = pOutputDir.getAbsolutePath() + File.separator;
		}

		// write out XML files

		for (Map.Entry<String, ReferenceSequence> e : refSeqs.entrySet()) {
			if (task != null && task.isInterrupted()) {
				throw new InterruptedException("Interrupted!");
			}

			String referenceSequenceName = e.getKey();
			ReferenceSequence referenceSequence = e.getValue();

			String fileName = fileNamePrefix + referenceSequenceName
					+ ".strains.xml";
			File f = new File(fileName);

			// System.out.println("writing XML to " + f.getAbsolutePath() + "/"
			// + f.getName());
			try {
				Util.writeStrainsToXML(referenceSequence, f, "default", true);
			} catch (IOException ex) {
				System.err.println("Could not write " + fileName + ": "
						+ ex.toString());
			}
		}
	}

	/**
	 * put each reamaining read in its own strain and add to entry
	 */
	private void processSoloReads(
			Map<Read, Map<String, Alignment>> pReadAlignmentsMap) {
		for (Map.Entry<Read, Map<String, Alignment>> e : pReadAlignmentsMap
				.entrySet()) {
			// for each solo read...
			Read read = e.getKey();
			Map<String, Alignment> aligs = e.getValue();

			// get the best alignment
			findBestAlignment(read, aligs);
		}
	}

	// try to find the highest scoring pair of alignments that
	// put the read and its mate pair within smallClone to bigClone bases of
	// each other
	private boolean findBestAlignments(Read read,
			Map<String, Alignment> rAligs, Read mp,
			Map<String, Alignment> mpAligs)
			throws NoGoodClonePlacementException {
		int bestScore = 0;
		// String bestSubject = null;
		Alignment bestReadAlig = null;
		Alignment bestMPAlig = null;

		for (Map.Entry<String, Alignment> rE : rAligs.entrySet()) {
			String rSubject = rE.getKey();
			Alignment rAlig = rE.getValue();

			for (Map.Entry<String, Alignment> mpE : mpAligs.entrySet()) {
				String mpSubject = mpE.getKey();
				Alignment mpAlig = mpE.getValue();

				// do these alignments refer to the same reference sequence
				if (mpSubject.equals(rSubject)) {
					int score = rAlig.score + mpAlig.score;
					if (score > bestScore) {
						int separation = Math.max(
								Math.abs(rAlig.getStart() - mpAlig.getEnd()),
								Math.abs(mpAlig.getStart() - rAlig.getEnd()));
						if (separation < bigClone && separation > smallClone) {
							bestScore = score;
							// bestSubject = mpSubject;
							bestReadAlig = rAlig;
							bestMPAlig = mpAlig;
						}
					}
				}
			}
		}

		if (bestScore == 0) {
			return false;
		}

		// set alignments
		read.setAlignment(bestReadAlig);
		read.setLength(bestReadAlig.getSequenceSegment2().getLength());
		mp.setAlignment(bestMPAlig);
		mp.setLength(bestMPAlig.getSequenceSegment2().getLength());

		// add to reference seqnce
		ReferenceSequence referenceSequence = (ReferenceSequence) bestReadAlig
				.getSequenceSegment1().getSequence();
		referenceSequence.reads.put(read.getIdInteger(), read);
		referenceSequence.reads.put(mp.getIdInteger(), mp);

		// build clone based strain (i.e. a strain that only contains this read
		// and its mate pair)
		Strain cloneStrain = new Strain();
		cloneStrain.setId(strainIndex++);
		cloneStrain.putRead(read.getIdInteger(), read);
		cloneStrain.putRead(mp.getIdInteger(), mp);
		// mpStrain.setAlignmentFromReads();
		referenceSequence.putStrain(cloneStrain.getIdInteger(), cloneStrain);

		// read.initializeGraphics();
		// mp.initializeGraphics();

		return true;
	}

	private void findBestAlignment(Read read, Map<String, Alignment> aligs) {
		int bestScore = 0;
		Alignment bestAlig = null;
		// String bestSubject = null;

		for (Map.Entry<String, Alignment> e : aligs.entrySet()) {
			// String subject = e.getKey();
			Alignment a = e.getValue();
			if (a.score > bestScore) {
				bestScore = a.score;
				bestAlig = a;
				// bestSubject = subject;
			}
		}

		if (bestAlig == null) {
			System.out.println("found no aligs with score > 0 in "
					+ aligs.size() + " aligs");
			return;
		}

		ReferenceSequence referenceSequence = (ReferenceSequence) bestAlig
				.getSequenceSegment1().getSequence();
		referenceSequence.reads.put(read.getIdInteger(), read);
		read.setBadClone(true);
		read.setAlignment(bestAlig);
		read.setLength(bestAlig.getSequenceSegment2().getLength());
		Strain strain = new Strain();
		strain.setId(strainIndex++);
		strain.putRead(read.getIdInteger(), read);
		// strain.setAlignmentFromReads();
		referenceSequence.putStrain(strain.getIdInteger(), strain);
		referenceSequence.maxStrainId = Math.max(referenceSequence.maxStrainId,
				strainIndex);
	}
}
