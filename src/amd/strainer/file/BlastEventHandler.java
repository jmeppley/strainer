/****** BEGIN LICENSE BLOCK *****
 * This file is part of the Strainer application. To obtain or learn more 
 * about strainer visit: 
 *  http://bioinformatics.org/strainer
 * 
 * Copyright (c) 2007 The Regents of the University of California.  All rights
 * reserved.
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of the GNU Lesser General Public License as published 
 * by the Free Software Foundation; either version 2.1 of the License, or 
 * (at your option) any later version. You may not use this file except in 
 * compliance with the License. 
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  
 * USA or visit http://www.gnu.org/licenses/lgpl.html
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 * 
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING
 * DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED "AS
 * IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS. 
 *
 * Contributor(s):
 *  John Eppley <jmeppley@berkeley.edu>
 * 
 ***** END LICENSE BLOCK ***** */
package amd.strainer.file;

import java.util.HashMap;
import java.util.Map;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

import amd.strainer.NoGoodClonePlacementException;
import amd.strainer.display.actions.Task;
import amd.strainer.objects.Alignment;
import amd.strainer.objects.Read;
import amd.strainer.objects.ReferenceSequence;
import amd.strainer.objects.Strain;

/**
 * Handles SAX events as generated by BlastLikSAXParser. Used to parse blastn
 * alignments of reads against a reference sequence.
 * <p>
 * To generate a file for importing into strainer, first obtain a sequence file
 * for the reference sequence plus a file of read sequences in FASTA format.
 * First, create a blast DB using just the reference sequence. Next, Blast the
 * list of read sequences against the generated database. Output the results in
 * m0 format. Use the original reference sequence file (FASTA or GenBank) and
 * the blast output to open strainer.
 * 
 * @author jmeppley
 * 
 */
public class BlastEventHandler extends DefaultHandler {
	// the object to add reads to
	ReferenceSequence referenceSequence = null;

	// keep counts so we can assign ID numbers
	int readIndex = 1;
	int strainIndex = 1;

	// mate pair separation
	int smallClone = 0;
	int bigClone = -1;
	private Integer scoreCutoff = 0;

	// save reads as we encounter them
	Read currentRead = null;
	Map<String, Read> soloReads = new HashMap<String, Read>();
	Map<String, Alignment> currentReadAlignments = new HashMap<String, Alignment>();
	Map<Read, Map<String, Alignment>> readAlignmentsMap = new HashMap<Read, Map<String, Alignment>>();

	// Alignment data
	String subjectId = null;
	boolean dir = true;
	int score = 0;
	int length = 0;
	String eValue = null;
	int astart = 0;
	int aend = 0;
	boolean inSequence = false;
	StringBuffer chars = new StringBuffer();
	private String query = null;
	private String match = null;
	private String hit = null;
	private String cigar = null;
	Task mTask = null;

	/**
	 * Creates the event handler.
	 * 
	 * @param pRefSeq
	 *            the ReferenceSequence object to be filled with Read
	 *            alignments.
	 * @param pSmallClone
	 *            the smallest clone size (separation of matepairs) expected
	 * @param pBigClone
	 *            the largest clone size expected
	 * @param pScoreCutoff
	 *            the minimum score for an alignment
	 * @param pTask
	 *            Task to take progress updates, may be null
	 */
	public BlastEventHandler(ReferenceSequence pRefSeq, int pSmallClone,
			int pBigClone, Integer pScoreCutoff, Task pTask) {
		referenceSequence = pRefSeq;
		this.smallClone = pSmallClone;
		this.bigClone = pBigClone;
		this.scoreCutoff = pScoreCutoff;
		mTask = pTask;
	}

	/**
	 * Creates the event handler.
	 * 
	 * @param pRefSeq
	 *            the ReferenceSequence object to be filled with Read
	 *            alignments.
	 * @param pSmallClone
	 *            the smallest clone size (separation of matepairs) expected
	 * @param pBigClone
	 *            the largest clone size expected
	 * @param pScoreCutoff
	 *            the minimum score for an alignment
	 */
	public BlastEventHandler(ReferenceSequence pRefSeq, int pSmallClone,
			int pBigClone, Integer pScoreCutoff) {
		referenceSequence = pRefSeq;
		this.smallClone = pSmallClone;
		this.bigClone = pBigClone;
		this.scoreCutoff = pScoreCutoff;
	}

	/**
	 * Receive notification of the beginning of a document. (ignored)
	 */
	@Override
	public void startDocument() {
	}

	/**
	 * Receive notification of the beginning of an element.
	 */
	@Override
	public void startElement(java.lang.String uri, java.lang.String localName,
			java.lang.String qName, Attributes atts) {
		if (mTask != null && mTask.isInterrupted()) {
			throw new RuntimeException("Interrupted!");
		}

		// System.out.println("Start " + qName);

		if (qName.equals("biojava:BlastLikeDataSet")) {
			// notify task of status update
			if (mTask != null) {
				mTask.setCurrent(readIndex - 1);
			}

			// initialize read
			currentRead = new Read();
			currentRead.setId(readIndex++);
		} else if (currentRead != null) {
			if (qName.equals("biojava:QueryId")) {
				// get the read name
				currentRead.setName(atts.getValue("id"));
			} else if (qName.equals("biojava:HitId")) {
				// store name of sequence matched
				subjectId = atts.getValue("id");
			} else if (qName.equals("biojava:HSPSummary")) {
				// save alignment info
				dir = atts.getValue("hitStrand").equals(
						atts.getValue("queryStrand"));
				score = (int) Float.parseFloat(atts.getValue("score"));
				length = Integer.parseInt(atts.getValue("alignmentSize"));
				eValue = atts.getValue("expectValue");
			} else if (qName.equals("biojava:QuerySequence")) {
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			} else if (qName.equals("biojava:MatchConsensus")) {
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			} else if (qName.equals("biojava:CigarString")) {
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			} else if (qName.equals("biojava:HitSequence")) {
				// get alignment position
				astart = Integer.parseInt(atts.getValue("startPosition"));
				aend = Integer.parseInt(atts.getValue("stopPosition"));
				// flag to grab any chars in this element as sequence data
				inSequence = true;
				chars.delete(0, chars.length());
			}
		}
	}

	/**
	 * Receive notification of character data.
	 */
	@Override
	public void characters(char[] ch, int start, int length) {
		if (inSequence) {
			// save data if we are in a sequence element only
			chars.append(ch, start, length);
		}
	}

	/**
	 * Receive notification of the end of an element.
	 */
	@Override
	public void endElement(java.lang.String uri, java.lang.String localName,
			java.lang.String qName) {
		if (mTask != null && mTask.isInterrupted()) {
			throw new RuntimeException("Interrupted!");
		}

		// System.out.println("End   " + qName);

		if (qName.equals("biojava:BlastLikeDataSetCollection")) {
			// End of data
			if (bigClone > 0) {
				// look through leftover reads and add to reference seq with
				// best alignments
				addSoloReadsToReferenceSequence(readAlignmentsMap,
						referenceSequence);
			}
		} else if (currentRead != null) {
			if (qName.equals("biojava:BlastLikeDataSet")) {
				// end of read. Clean up and save

				if (currentRead.getName() == null
						|| currentReadAlignments.size() == 0) {
					// incomplete record, skip
					return;
				}

				// get id of read as nteger for convienience
				Integer readId = currentRead.getIdInteger();

				// check if we've seen it's matepair...
				Read matePair = null;
				// (don't bother unless user specified clone size for mate pair
				// linking)
				if (bigClone > 0) {
					matePair = Util.lookForMatePair(soloReads, currentRead,
							false);
				}

				// if so ...
				if (matePair != null) {
					// if we've seen the mate pair...
					// choose which alignment is best for this pair

					// start by getting alig data for mp
					Map<String, Alignment> mpAligs = readAlignmentsMap
							.remove(matePair);
					try {
						if (findBestAlignments(referenceSequence.getName(),
								currentRead, currentReadAlignments, matePair,
								mpAligs)) {
							// we'll only get here if the findBestAlignment
							// method deemed this reference sequence to be the
							// best match for the mate pair

							// add to referenceSequence
							referenceSequence.reads.put(readId, currentRead);
							referenceSequence.reads.put(
									matePair.getIdInteger(), matePair);

							// link pair and create clone
							currentRead.setMatepair(matePair);

							// build clone based strain
							Strain cloneStrain = new Strain();
							Integer strainId = currentRead.getClone()
									.getIdInteger();
							cloneStrain.setId(strainId.intValue());
							cloneStrain.putRead(readId, currentRead);
							cloneStrain.putRead(matePair.getIdInteger(),
									matePair);
							cloneStrain.setAlignmentFromReads();
							referenceSequence.putStrain(strainId, cloneStrain);

							currentRead.initializeGraphics();
							matePair.initializeGraphics();
						} else {
							// we get here if the best alignment was not to this
							// reference sequence.
							// do nothing
						}
					} catch (NoGoodClonePlacementException e) {
						// if nothing fell within tolerances, choose the best
						// individual scores
						Alignment rA = findBestAlignment(
								referenceSequence.getName(),
								currentReadAlignments);
						Alignment mpA = findBestAlignment(
								referenceSequence.getName(), mpAligs);
						// mark both reads from matePair ass poorly aligned
						if (rA != null) {
							referenceSequence.reads.put(readId, currentRead);
							if (mpA != null)
								currentRead.setBadClone(true);
							currentRead.setAlignment(rA);
							currentRead.setLength(rA.getSequenceSegment2()
									.getLength());
							Strain strain = new Strain();
							strain.setId(strainIndex++);
							strain.putRead(currentRead.getIdInteger(),
									currentRead);
							strain.setAlignmentFromReads();
							referenceSequence.putStrain(strain.getIdInteger(),
									strain);
							referenceSequence.maxStrainId = Math.max(
									referenceSequence.maxStrainId, strainIndex);
						}
						if (mpA != null) {
							referenceSequence.reads.put(
									matePair.getIdInteger(), matePair);
							if (rA != null)
								matePair.setBadClone(true);
							matePair.setAlignment(mpA);
							matePair.setLength(mpA.getSequenceSegment2()
									.getLength());
							Strain strain = new Strain();
							strain.setId(strainIndex++);
							strain.putRead(matePair.getIdInteger(), matePair);
							strain.setAlignmentFromReads();
							referenceSequence.putStrain(strain.getIdInteger(),
									strain);
							referenceSequence.maxStrainId = Math.max(
									referenceSequence.maxStrainId, strainIndex);
						}
						if (rA != null && mpA != null) {
							currentRead.setMatepair(matePair);
						}
					}
				} else {
					if (bigClone > 0) {
						// if we haven't seen the mate pair yet...
						// save alignments for later and wait for mate pair to
						// come around
						readAlignmentsMap.put(currentRead,
								currentReadAlignments);
					} else {
						// we're not tracking matepairs, so just add read
						alignSoloReadToReferenceSequence(currentRead,
								currentReadAlignments, referenceSequence);
					}
				}

				currentRead = null;
				currentReadAlignments = new HashMap<String, Alignment>();
			} else if (qName.equals("biojava:HSP")) {
				Alignment a;
				// end of an HSP, add just created Alignment to list of
				// possibles for this read
				if (match != null) {
					a = Util.buildAlignmentFromBlastData(currentRead,
							referenceSequence, dir, astart, aend, score,
							length, eValue, query, match, hit);
				} else if (cigar != null) {
					a = Util.buildAlignmentFromCigarString(currentRead,
							referenceSequence, dir, astart, score, eValue,
							query, cigar);
				} else {
					throw new RuntimeException(
							"Did not get a match string or cigar string. This file is not readable.");
				}
				currentReadAlignments.put(subjectId, a);
			} else if (qName.equals("biojava:QuerySequence")) {
				query = chars.toString();
				inSequence = false;
			} else if (qName.equals("biojava:MatchConsensus")) {
				match = chars.toString();
				inSequence = false;
			} else if (qName.equals("biojava:HitSequence")) {
				hit = chars.toString();
				inSequence = false;
			} else if (qName.equals("biojava:CigarString")) {
				cigar = chars.toString();
				inSequence = false;
			}
		}
	}

	/**
	 * Receive notification of the end of a document.
	 */
	@Override
	public void endDocument() {
	}

	/**
	 * put each reamaining read in its own strain and add to refrenceSEquence
	 * object
	 */
	private void addSoloReadsToReferenceSequence(
			Map<Read, Map<String, Alignment>> pReadAlignmentsMap,
			ReferenceSequence pRefSeq) {
		for (Map.Entry<Read, Map<String, Alignment>> e : pReadAlignmentsMap
				.entrySet()) {
			// for each solo read...
			Read read = e.getKey();
			Map<String, Alignment> aligs = e.getValue();
			alignSoloReadToReferenceSequence(read, aligs, pRefSeq);
		}
	}

	private void alignSoloReadToReferenceSequence(Read read,
			Map<String, Alignment> aligs, ReferenceSequence pRefSeq) {
		// get the best alignment
		Alignment a = findBestAlignment(pRefSeq.getName(), aligs);
		if (a == null) {
			// either there was no alignment or the best alignment was not to
			// this reference sequence
			// skip
			return;
		}
		pRefSeq.reads.put(read.getIdInteger(), read);
		read.setAlignment(a);
		read.setLength(a.getSequenceSegment2().getLength());
		Strain strain = new Strain();
		strain.setId(strainIndex++);
		strain.putRead(read.getIdInteger(), read);
		strain.setAlignmentFromReads();
		referenceSequence.putStrain(strain.getIdInteger(), strain);
		referenceSequence.maxStrainId = Math.max(referenceSequence.maxStrainId,
				strainIndex);
		read.initializeGraphics();
	}

	// try to find the highest scoring pair of alignments that
	// put the read and its mate pair within the smallClone to bigClone range
	private boolean findBestAlignments(String refSeqName, Read read,
			Map<String, Alignment> rAligs, Read mp,
			Map<String, Alignment> mpAligs)
			throws NoGoodClonePlacementException {
		Integer bestScore = scoreCutoff;
		String bestSubject = null;
		Alignment bestReadAlig = null;
		Alignment bestMPAlig = null;

		for (Map.Entry<String, Alignment> rE : rAligs.entrySet()) {
			String rSubject = rE.getKey();
			Alignment rAlig = rE.getValue();

			for (Map.Entry<String, Alignment> mpE : mpAligs.entrySet()) {
				String mpSubject = mpE.getKey();
				Alignment mpAlig = mpE.getValue();

				// do these alignments refer to the same reference sequence
				if (mpSubject.equals(rSubject)) {
					int score = rAlig.score + mpAlig.score;
					if (bestScore == null || score > bestScore) {
						int separation = Math.max(
								Math.abs(rAlig.getStart() - mpAlig.getEnd()),
								Math.abs(mpAlig.getStart() - rAlig.getEnd()));
						if (separation < bigClone && separation > smallClone) {
							bestScore = score;
							bestSubject = mpSubject;
							bestReadAlig = rAlig;
							bestMPAlig = mpAlig;
						}
					}
				}
			}
		}

		if (bestScore == null
				|| (scoreCutoff != null && bestScore <= scoreCutoff)) {
			throw new NoGoodClonePlacementException();
		}

		if (!bestSubject.equals(refSeqName)) {
			return false;
		}

		// set alignments
		read.setAlignment(bestReadAlig);
		read.setLength(bestReadAlig.getSequenceSegment2().getLength());
		mp.setAlignment(bestMPAlig);
		mp.setLength(bestMPAlig.getSequenceSegment2().getLength());
		return true;
	}

	private Alignment findBestAlignment(String pRefSeqName,
			Map<String, Alignment> aligs) {
		Integer bestScore = scoreCutoff;
		Alignment bestAlig = null;
		String bestSubject = null;

		for (Map.Entry<String, Alignment> e : aligs.entrySet()) {
			String subject = e.getKey();
			Alignment a = e.getValue();
			if (bestScore == null || a.score > bestScore) {
				bestScore = a.score;
				bestAlig = a;
				bestSubject = subject;
			}
		}

		if (bestAlig == null) {
			System.out
					.println("found no aligs with score > "
							+ scoreCutoff.toString() + " in " + aligs.size()
							+ " aligs");
			return null;
		}

		if (!bestSubject.equals(pRefSeqName)) {
			// best alignment is not to this reference sequence. Return null
			return null;
		}

		return bestAlig;
	}
}
